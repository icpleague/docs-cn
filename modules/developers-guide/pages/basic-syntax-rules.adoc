= 学习 {proglang} 的基础知识
2019 年 12 月（阿尔法）
:proglang: Motoko
:平台：互联网计算机平台
:IC: 互联网计算机
:ext: .mo
:company-id: DFINITY

{platform} 的一个关键特性是 {proglang} 编程语言。
{proglang} 编程语言是一种高级通用语言，类似于其他现代编程语言，但专门设计用于有效处理异步消息传递。

尽管 {proglang} 提供了一个可以交互使用的解释器和一个独立的编译器，但您可以编写程序和编译您的代码，而无需直接使用其中任何一个。
相反，在大多数情况下，您通过您选择的编辑器并使用 `+dfx+` 命令行执行工具间接与编程语言交互。

为了帮助您开始使用这种新语言，本节提供了该语言的简要概述，并描述了使用 {proglang} 编写程序的一些基本约定。
有关在 {proglang} 中编程的更完整信息，包括特定语言功能和详细示例，请参阅_语言参考指南_。

== Actors 和异步消息传递

当您开始探索 {proglang} 编程语言时，您应该记住，每个应用程序都由一个 *actor* 组成，它通过异步传递消息与其他参与者通信。

Actor 是一种特殊的对象，它以隔离状态传递其消息。
当您定义一个参与者时，它的消息会按顺序处理，但彼此隔离。 作为使用演员的示例，请考虑以下程序：

[source,bash]
----
let result1 = await service1.computeAnswer(params);
let result2 = await service2.computeAnswer(params);
finalStep(result1, result2)
----

在此示例中，程序向两个不同的服务发出两个请求。
每个服务都在内部作为参与者（对象）实现。
程序使用 `+await+` 关键字按顺序等待每个结果值。
然后程序在最后一步使用每个请求的结果，调用函数`+finalStep+`。

基于参与者的编程模型特别适合编写旨在在 {platform} 上运行的程序。
但是，您也可以在 {proglang} 中编写程序以在其他平台和其他框架内运行。
如果您正在编写在其他平台上运行的程序，您可能根本不使用参与者对象或异步消息传递。

== 接口描述和{proglang}

为了支持多语言和跨语言通信，{proglang} 编译器自动生成和使用接口描述。
{proglang} 编译器使用 {proglang} 程序中的类型签名和导入的预定义接口的结构生成接口描述。

== Prelude 和标准库函数

与其他语言一样，{proglang} 在预定义的前奏和标准库文件中包含许多常用函数，您可以将它们导入程序中。
通过导入 prelude 或标准库，您可以使用诸如 `println` 之类的常用函数，而无需在程序中明确定义它们。

例如，您可能包括类似于以下的行来从标准库中导入列表函数：

[source,bash]
----
import List "../../motoko/base/list";
----

== 基本语言功能

本节描述了在 {proglang} 中编程需要了解的基本语言约定。

=== 评论

您可以使用单行、多行或嵌套的多行注释在代码中包含描述性的非可执行文本。
例如，使用注释来添加有关代码块的上下文，作为给您自己的注释或作为您想要与任何审查或维护您的代码的人共享的信息。
格式正确的注释被视为空白并被编译器忽略。

==== 单行注释

单行注释以两个正斜杠 (//) 开头，由 `+//+` 之后的字符组成，直到同一行的末尾。
例如，您可以在上面、下面或与注释适用的代码相同的行上添加单行注释。

[source,bash]
----
// This is a single-line comment on its own line above relevant code
import List = "ListLib";
----

==== 多行和嵌套注释

您还可以包含单行、多行和嵌套的多行注释，方法是以正斜杠开头，后跟星号 (/\*)，以星号结尾，后跟正斜杠 (*/)。
例如：

[source,bash]
----
/* 
This is a comment that is split into 
multiple lines. 
*/
----

您还可以通过启动一个多行注释块，然后在第一个块中启动第二个多行注释来编写嵌套的多行注释。
例如：

[source,bash]
----
/* 这是第一个多行注释块的开始。
    /* 这是第二个嵌套的多行注释。 */
这是第一个多行注释块的结尾。 */
----

=== 程序、声明和表达式

每个 {proglang} 程序由零个或多个声明组成，后跟一个可选表达式。
例如，下面的代码片段由变量`+x+`和`+y+`的两个声明组成，后跟一个表达式，形成一个程序：

[source,bash]
----
let x = 1;
let y = x + 1;
x * y + x;
----

如本例所示，您使用分号 (;) 来终止声明和表达式。 例如，要计算一个简单的方程：

[source,bash]
----
1 + 3; // When executed, the result would be "4 : Nat" value and type
----

== 数字、文本和运算符

{proglang} 支持以下数字类型：

* 自然数 (`+Nat+`) 是正整数。
* 整数 (`+Int+`) 是正、负或零整数值。
* 浮点数 (`+Float+`) 是 32 位或 64 位小数数值。

基本算术运算符按您的预期工作。 例如：

[source,bash]
----
1 + 1;      // = 2
0.1 + 0.2;  // = 0.3
8 - 1;      // = 7
10 * 2;     // = 20
35 / 5;     // = 7
----

您可以使用双 (") 引号将文本括起来。例如：

[source,bash]
----
let name = "Chris"; // let name : Text = "Chris"
----

=== 关系运算符

您可以在 {proglang} 程序中使用以下关系运算符。

[cols=",",options="header",]
|===
|使用此 |定义此关系
|`+␣<␣+` |小于。 运算符必须用空格括起来。
|`+␣>␣+` |大于。 运算符必须用空格括起来。
|`+==+` |等于。
|`+!=+` |不等于。
|`+<=+` |小于或等于。
|`+>=+` |大于或等于。
|===

=== 数字二元运算符

[cols=",",options="header",]
|===
|使用此 |用于此操作
|`+++` |加法。
|`+-+` |减法。
|`+*+` |乘法。
|`+/+` |除法。
|`+%+` |取模。
|`++**+` |求幂。
|===

=== 位二元运算符

[cols=",",options="header",]
|===
|使用此 |用于此操作
|`+&+` |按位与。
|`+\|+` |按位或。
|`+^+` |异或。
|`+<<+` |左移。
|`+␣>>+` |右移。 运算符前面必须有空格。
|`+<<>+` |向左旋转。
|`+<>>+` |向右旋转。
|===

=== 字符串运算符

[cols=",",options="header",]
|===
|使用此 |用于此操作
|`+#+` |文本连接。
|===

=== 赋值运算符

[cols=",",options="header",]
|===
|使用此 |用于此操作
|`+:=+` |使用就地更新的分配。
|`++=+` |就地添加。
|`+-=+` |就地减法。
|`+*=+` |就地乘法。
|`+/=+` |就地划分。
|`+%=+` |就地取模。
|`+**=+` |就地取幂。
|`+&=+` |就地逻辑与。
|`+\|=+` |就地逻辑或。
|`+^=+` |就地异或。
|`+<<=+` |原地左移。
|`+>>=+` |原地右移。
|`+<<>=+` |原地向左旋转。
|`+<>>=+` |原地向右旋转。
|`+#=+` |就地串联。
|===

=== 变量

变量使您能够将静态名称和类型与仅在执行程序时出现的动态值相关联。

您可以使用 `+let+` 关键字声明变量名和数据类型（如有必要）。 例如，您可以使用以下表示法将变量 `+x+` 设置为自然数 1：

[source,bash]
----
let x : Nat = 1;
----

在这个例子中，编译器可以推断出表达式 1 的类型为 `+Nat+`，而 `+x+` 的类型相同。 因此，您可以在不改变程序含义的情况下使用以下注解：

[source,bash]
----
let x = 1
----

=== 原始值

{proglang} 支持以下原始类型：

* 布尔值（真，假）
* 整数 (…​,-2, -1, 0, 1, 2, …​)
* 自然数 (0, 1, 2, ...​)
* 单词（固定宽度的数字）
* 字符（Unicode 代码点）
* 文本值（Unicode 字符的字符串）

整数和自然数不会默默地溢出或溢出。
相反，他们使用增长来适应任何有限数字的表示。 还有固定宽度的整数和自然数（8 位、16 位、32 位和 64 位）类型会捕获算术溢出和下溢。 固定宽度的整数是有符号的。 固定宽度的自然数是无符号的。

字值具有固定宽度。 字类型的算术使用模 2**N 执行，其中 N 是字类型的位宽。

{proglang} 不允许未检查、未捕获的溢出。

所有原始类型都是可共享的，以便可以跨远程函数调用发送和接收它们。

=== 非原始值

基于上面的原始值和类型，该语言允许用户定义类型，以及以下每种非原始值形式和相关类型：

* 元组，包括单位值（“空元组”）。
* 不可变和可变形式的数组。
* 具有命名的、无序的字段和方法的对象。
* 变体，具有命名构造函数和可选的有效负载值。
* 函数值，包括可远程调用的可共享函数。
* 异步值，也称为 *futures* 或 *promises*，可以使用 `+await+` 进行同步。
* 可选值，可以是 `+null+` 或 `+? v+`，以获得正确的值`+v+`。


请注意，如果您的函数返回类型为 `+T+` 的可选值，则该函数的返回类型应为 '? T'：
用问号 (?) 为类型添加前缀会添加 `null` 值。
例如，您将使用以下语法来指示由 `+?Phone+` 标识的类型的返回值是可选的（例如，返回值可以是 `+null+` 以及正确的电话号码）：

[source,motoko,no-repl,subs="quotes"]
----
public query func lookup(name: Name): async *?Phone* {
        return A.find<Name, Phone>(book, name, nameEq);
    };
----

=== 功能

一等函数支持多个参数和返回，并且可以是多态的。

* `+T -> U+`
* `+(T, U) -> (V, W)+`
* `+(x : T, y : U) -> V+`
* `+<A, B>(x : T, y : U) -> (V, W)+`

Functions can be defined as `+public+` or `+private+`, `+shared+`, or locally-scoped.


=== 对象和演员

对象是结构记录类型，其字段可以是可变的或不可变的。
具有不可变字段的对象是可共享的。

....
{var x : Int; color : Color}
{x : Int; color: Color}
....

Actor 是具有以下特征的受限对象：

* 状态必须是孤立的。
* 公共方法是隐含的`+shared+`。
* 所有交互都是异步的。

Actor 对象被标记为 `+actor+`，语法类似于
下列的：

....
actor {
  private var c = 0;
  public func inc() { c += 1 };
  public func get() : async Int { c }
}
....

Actor 的字段是返回以下任一函数的函数：

* 空单元返回类型 `+()+`，类似于 `+void+` 返回值。
* 一个`+async+`返回类型，本质上是一个`+promise+`返回一个未来值。

=== 数组

您可以定义不可变或可变数组。
不可变数组和可变数组使用的赋值语法相同，但分配后不能更改不可变数组。

下面是一个简单的、不可变数组的示例，它包含三个自然数，类型为 `+[Nat]+`：

[source,bash]
----
let test_array : [Nat] = [1, 2, 3] ;
----

通常，不可变数组在数组元素的类型周围使用方括号，这些元素必须共享一个通用类型。
因为不可变数组不能被修改，所以不可变数组可以安全地发送和共享。

与不可变数组不同，{proglang} 中的每个可变数组都引入了一个私有的 Actor 状态，该状态可以在本地使用，但不能在需要不可变数组的情况下使用。
可变数组不能在消息中共享或发送。
有关使用数组的更多信息，请参阅_{proglang} 语言参考_。

=== 元组

元组是包含一系列元素的数据结构。
序列中元素的数量是固定的，但元素可以由不同的数据类型组成。
当您希望为具有特定属性的对象提供数据结构但又不想为其创建单独的类型时，通常会使用元组。

以下示例使用整数为三维点定义一个元组，以指定位置来表示 x 轴、y 轴和 z 轴上的点以及颜色。

[source,bash]
----
  type Point3D = (Int, Int, Int, Color);
  let origin = (0, 0, 0, Color.Red);
  let (x, y, z, _) = origin;

  func isOrigin(p : Point3D) : Bool {
    switch p {
      case (0, 0, 0, _) true; // pattern match
      case _ false;
    }
  }
----

=== 条件和切换

{proglang} 支持所有用于表达条件和在案例之间切换的常见结构。

例如，您可以编写 `+if+` 和 `+if else+` 条件，其语法类似于以下：

[source,bash]
----
if <exp>
  ...
----

[source,bash]
----
if <exp>
  ... 
else <exp>
  ...
----

您还可以使用类似于以下的 `+switch` 和 `+case` 语法：

[source,bash]
----
switch <exp> { 
  case 1 
    ...;
  case 2 
    ...;
  case 3
    ...}
----

=== While, Loops, and iteration

* `+while (p()) ...+`
* `+loop ...+`
* `+loop ... while (p())+`
* `+for (x in f()) ...+`

=== 标记、中断和继续

标签有助于确保控制流是结构化的，并且可以与 `+break+` 和 `+continue+` 关键字一起使用。

* `+label l exp+`
* `+break l+` (more generally, `+break l exp+`)
* `+continue l+`

== 标识符

标识符是字母数字的。
它们必须以大写或小写字母开头，并且可以包含大写或小写字母、数字和下划线的组合。

== 保留关键字

以下关键字保留用于特定目的，不能在 {proglang} 代码中用作标识符或用于任何其他目的：

[width="100%",cols="40%,60%",options="header",]
|===
|此关键字 |为此目的而保留
|actor |声明参与者标识符、参与者对象和参与者类。

|and |Boolean conjunction (short-circuiting).

|async |声明一个异步函数或创建一个future。

|assert |断言布尔属性（假时捕获）。

|await |等待异步计算的结果。

|break |从带标签的表达式或循环（可能带有值）中退出。

|case |前面的 `switch` 表达式的大小写，由模式和表达式组成。

|catch |前面的 `try` 表达式的失败分支。

|class |类声明（参与者、对象和模块类）。

|continue |继续“loop”或“while”或“for”的下一次迭代。

|debug |条件调试表达式，从`release`代码中排除。

|debug_show |显示调试消息。

|else |条件表达式的假分支。

|false |布尔文字值 *false*。

|for |迭代迭代器的项目。

|func |声明一个名称函数或匿名函数值。

|If |在布尔值上分支。

|ignore |丢弃表达式的值。

|import |将源文件或其他资源作为命名模块导入。

|in |指示 `for` 循环的域。

|module |声明一个模块标识符或模块表达式。

|not |否定布尔值。

|null |类型为“Null”的文字值。

|object |声明一个对象标识符或对象表达式。

|or|布尔析取（短路）。

|label |标记一个表达式以通过 `break` 提前退出。

|let |将标识符（或模式）绑定到值。

|loop |进入一个循环（可能带有一个受保护的出口）。

|private |将声明的可见性限制为封闭
演员、对象、模块或类。

|public |作为附件成员发布声明
演员、对象、模块或类。

|query |在不修改状态的情况下返回结果的共享函数的修饰符。

|return |从函数或异步块中退出（可能带有值）。

|shared |声明一个可以远程调用的函数。

|switch |条件模式匹配，由案例定义。

|throw |从有错误的表达式中退出。

|true |作为比较结果返回的布尔值。

|try |声明一个作用域错误处理程序。

|type |声明一个类型缩写。

|var |指定可更新的（可变）变量、字段或数组。

|while |输入一个保护循环。
|===